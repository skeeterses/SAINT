(ql:quickload "trivia")
(use-package :trivia)

(defun elf (func)
  (match func
	 ((guard (list a) (dx? a))
	  (list (char a 1)))
	 ((guard (list a b)
		 (and (constant? a) (dx? b)))
	  (list a (char b 1)))
	 ((guard (list (list 'exp a) b)
		 (and (variable? a) (dx? b)))
		 (list 'exp a))
	 ((guard (list (list 'sin a) b)
		 (and (variable? a) (dx? b)))
	  (list '- (list 'cos a)))
	 ((guard (list (list 'expt a b) c)
		 (and (constant? a) (variable? b) (dx? c)))
	  (list (list 'expt a b) '/ (list 'log b)))
	 ((guard (list (list 'log a b) c)
		 (and (constant? b) (variable? a) (dx? c)))
	  (list (list a (list 'log a b)) '- (list a '/ (list 'log b))))
	 ((guard (list (list 'cos a) b)
		 (and (variable? a) (dx? b)))
	  (list 'sin a))
	 ((guard (list (list 'tan a) b)
		 (and (variable? a) (dx? b)))
	  (list 'log (list 'sec a)))
	 ((guard (list (list 'cot a) b)
		 (and (variable? a) (dx? b)))
	  (list 'log (list 'sin a)))
	 ((guard (list (list 'sec a) b)
		 (and (variable? a) (dx? b)))
	  (list 'log (list (list 'sec a) '+ (list 'tan a))))
	 ((guard (list (list 'csc a) b)
		 (and (variable? a) (dx? b)))
	  (list 'log (list (list 'csc a) '- (list 'cot a))))
	 ((guard (list (list 'asin a) b)
		 (and (variable? a) (dx? b)))
	  (list a (list 'asin a) '+ (list 'sqrt (list 1 '- (list 'expt a 2)))))
	 ((guard (list (list 'acos a) b)
		 (and (variable? a) (dx? b)))
	  (list a (list 'acos a) '+ (list 'sqrt (list 1 '- (list 'expt a 2)))))
	 ((guard (list (list 'atan a) b)
		 (and (variable? a) (dx? b)))
	  (list a (list 'atan a) '- (list 'log (list 1 '+ (list 'expt a 2))) '/ 2))
	 ((guard (list (list 'acot a) b)
		 (and (variable? a) (dx? b)))
	  (list a (list 'acot a) '+ (list 'log (list 1 '+ (list 'expt a 2))) '/ 2))
	 ((guard (list (list 'asec a) b)
		 (and (variable? a) (dx? b)))
	  (list a (list 'asec a) '- (list 'log (list a '+ (list 'sqrt (list (list 'expt a 2) '- 1))))))
	 ((guard (list (list 'acsc a) b)
		 (and (variable? a) (dx? b)))
	  (list a (list 'acsc a) '+ (list 'log (list a '+ (list 'sqrt (list (list 'expt a 2) '- 1))))))
	 ((guard (list (list 'expt (list 'sec a) 2) b)
		 (and (variable? a) (dx? b)))
	  (list 'tan a))
	 ((guard (list (list 'expt (list 'csc a) 2) b)
		 (and (variable? a) (dx? b)))
	  (list '- (list 'cot a)))
	 ((guard (list b '/ a)
		 (and (variable? a) (dx? b)))
	  (list 'log a))
	 ((guard (list (list 'expt a -1) b)
		 (and (variable? a) (dx? b)))
	  (list 'log a))
	 ((guard (list a b)
		 (and (variable? a) (dx? b)))
	  (list (list 'expt a 2) '/ 2))
	 ((guard (list (list 'expt a b) c)
		 (and (variable? a) (numberp b) (dx? c)))
	  (list (list 'expt a (+ b 1)) '/ (+ b 1)))
	 ((guard (list (list 'expt a b) c)
		 (and (variable? a) (constant? b) (dx? c)))
	  (list (list 'expt a (list b '+ 1)) '/ (list b '+ 1)))
	 ((guard (list (list 'sec a) (list 'tan b) c)
		 (and (variable? a) (variable? b) (char= a b) (dx? c)))
	  (list 'sec a))
	 ((guard (list (list 'csc a) (list 'cot b) c)
		 (and (variable? a) (variable? b) (char= a b) (dx? c)))
	  (list '- 'csc a))
	 ((guard (list (list 'sin m a) (list 'cos n b) c)
		 (and (numberp m) (numberp n) (/= m n) (variable? a) (variable? b) (char= a b) (dx? c)))
	  (list '- (list (list 'cos (- m n) a) '/ (* 2 (- m n))) '-
		(list (list 'cos (+ m n) a) '/ (* 2 (+ m n)))))
	 ((guard (list (list 'sin m a) (list 'sin n b) c)
		 (and (numberp m) (numberp n) (/= m n) (variable? a) (variable? b) (char= a b) (dx? c)))
	  (list (list (list 'sin (- m n) a) '/ (* 2 (- m n))) '- 
		(list (list 'sin (+ m n) a) '/ (* 2 (+ m n)))))
	 ((guard (list (list 'cos m a) (list 'cos n b) c)
		 (and (numberp m) (numberp n) (/= m n) (variable? a) (variable? b) (char= a b) (dx? c)))
	  (list (list (list 'sin (- m n) a) '/ (* 2 (- m n))) '+
		(list (list 'sin (+ m n) a) '/ (* 2 (+ m n)))))))

(defun algTran (func)
  (cond
    ((and (constant? (car func)) (dx? (car (last func))))
     (list (car func) (integral (cdr func))))
    ((eq '- (car func))
     (list '- (integral (cdr func))))
    ((and (eq '+ (caar func)) (dx? (car (last func))))
     (append (list '+) (mapcar #'integral (insertDx (cdar func) (car (last func))))))
    (t nil)))
	  
(defun insertDx (sigma dx)
  (mapcar #'(lambda (x) (append (list x) (list dx))) sigma))

(defun integral (func)
  (cond ((elf func) (elf func))
	((algTran func) (algTran func))
	(t nil)))

(defun dx? (elem)
  (if (stringp elem)
    (and (= (length elem) 2)
	 (char= (char elem 0) #\d)
	 (alpha-char-p (char elem 1)))
    nil))

(defun duDx? (elem)
  (match elem
	 ((guard (list a '/ b) (and (dx? a) (dx? b)))
	  t)))

(defun constant? (elem)
  (cond ((numberp elem) elem)
	((characterp elem)
	 (if (upper-case-p elem)
	   elem
	   nil))
	 (t nil)))

(defun variable? (elem)
  (cond ((characterp elem)
	 (if (lower-case-p elem)
	   elem
	   nil))
	(t nil)))


(defun derive (func dx)
  (if (dx? dx)
      (cond ((constant? func) 0)
	    ((and (variable? func) (char= func (char dx 1)))
	     1)
	    ((variable? func)
	     (list (coerce (list #\d func) 'string) '/ dx))
	    ((= (length func) 1)
	     (derive (car func) dx))
	    ((negativeExpression? func)
	     (list '- (derive (cdr func) dx)))
	    ((and (listp func) (constant? (car func)))
	     (list (car func) (derive (cdr func) dx)))
	    ((eq '+ (car func))
	     (append (list '+) (mapcar #'(lambda (x) (derive x dx)) (cdr func))))
	    (t 
	      (scientificExpression func dx)))
      nil))

;(defun scientificExpression? (func)

(defun scientificExpression (func dx)
  (match func
	 ((guard (list 'sin a) (variable? a))
	  (list (list 'cos a) (derive a dx)))
	 ((guard (list 'cos a) (variable? a))
	  (list (list '- (list 'sin a)) (derive a dx)))))


(defun negativeExpression? (func)
  (if (equal '- (car func))
    t
    nil))


; Get '( _ ("dx")) to '(_ "dx")
(defun simplify (expression)
  (if (listp expression)
    (cond ((and (eq '* (cadr expression))
		(or (eq 0 (car expression)) (eq 0 (caddr expression))))
	   0)
	  ((and (eq '* (cadr expression)) (eq 1 (car expression)))
	   (caddr expression))
	  ((and (eq '* (cadr expression)) (eq 1 (caddr expression)))
	   (car expression))
	  ((and (eq '+ (cadr expression)) (eq 0 (car expression)))
	   (caddr expression))
	  ((and (eq '+ (cadr expression)) (eq 0 (caddr expression)))
	   (car expression))
	  ((and (eq '- (cadr expression)) (eq 0 (caddr expression)))
	   (car expression))
	  ((and (eq 'expt (car expression)) (eq 0 (caddr expression)))
	   1)
	  ((and (eq 'expt (car expression)) (eq 1 (caddr expression)))
	   (cadr expression))
	  (t expression))
    expression))

