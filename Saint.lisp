(ql:quickload "trivia")
(use-package :trivia)

(defun elf (func)
  (match func
	 ((guard (list a) (dx? a))
	  (list (char a 1)))
	 ((guard (list a b)
		 (and (constant? a) (dx? b)))
	  (list a (char b 1)))
	 ((guard (list (list 'exp a) b)
		 (and (variable? a) (dx? b)))
		 (list 'exp a))
	 ((guard (list (list 'sin a) b)
		 (and (variable? a) (dx? b)))
	  (list '- (list 'cos a)))
	 ((guard (list (list 'expt a b) c)
		 (and (constant? a) (variable? b) (dx? c)))
	  (list (list 'expt a b) '/ (list 'log b)))
	 ((guard (list (list 'log a b) c)
		 (and (constant? b) (variable? a) (dx? c)))
	  (list (list a (list 'log a b)) '- (list a '/ (list 'log b))))
	 ((guard (list (list 'cos a) b)
		 (and (variable? a) (dx? b)))
	  (list 'sin a))
	 ((guard (list (list 'tan a) b)
		 (and (variable? a) (dx? b)))
	  (list 'log (list 'sec a)))
	 ((guard (list (list 'cot a) b)
		 (and (variable? a) (dx? b)))
	  (list 'log (list 'sin a)))
	 ((guard (list (list 'sec a) b)
		 (and (variable? a) (dx? b)))
	  (list 'log (list (list 'sec a) '+ (list 'tan a))))
	 ((guard (list (list 'csc a) b)
		 (and (variable? a) (dx? b)))
	  (list 'log (list (list 'csc a) '- (list 'cot a))))
	 ((guard (list (list 'asin a) b)
		 (and (variable? a) (dx? b)))
	  (list a (list 'asin a) '+ (list 'sqrt (list 1 '- (list 'expt a 2)))))
	 ((guard (list (list 'acos a) b)
		 (and (variable? a) (dx? b)))
	  (list a (list 'acos a) '+ (list 'sqrt (list 1 '- (list 'expt a 2)))))
	 ((guard (list (list 'atan a) b)
		 (and (variable? a) (dx? b)))
	  (list a (list 'atan a) '- (list 'log (list 1 '+ (list 'expt a 2))) '/ 2))
	 ((guard (list (list 'acot a) b)
		 (and (variable? a) (dx? b)))
	  (list a (list 'acot a) '+ (list 'log (list 1 '+ (list 'expt a 2))) '/ 2))
	 ((guard (list (list 'asec a) b)
		 (and (variable? a) (dx? b)))
	  (list a (list 'asec a) '- (list 'log (list a '+ (list 'sqrt (list (list 'expt a 2) '- 1))))))
	 ((guard (list (list 'acsc a) b)
		 (and (variable? a) (dx? b)))
	  (list a (list 'acsc a) '+ (list 'log (list a '+ (list 'sqrt (list (list 'expt a 2) '- 1))))))
	 ((guard (list (list 'expt (list 'sec a) 2) b)
		 (and (variable? a) (dx? b)))
	  (list 'tan a))
	 ((guard (list (list 'expt (list 'csc a) 2) b)
		 (and (variable? a) (dx? b)))
	  (list '- (list 'cot a)))
	 ((guard (list b '/ a)
		 (and (variable? a) (dx? b)))
	  (list 'log a))
	 ((guard (list (list 'expt a -1) b)
		 (and (variable? a) (dx? b)))
	  (list 'log a))
	 ((guard (list a b)
		 (and (variable? a) (dx? b)))
	  (list (list 'expt a 2) '/ 2))
	 ((guard (list (list 'expt a b) c)
		 (and (variable? a) (numberp b) (dx? c)))
	  (list (list 'expt a (+ b 1)) '/ (+ b 1)))
	 ((guard (list (list 'expt a b) c)
		 (and (variable? a) (constant? b) (dx? c)))
	  (list (list 'expt a (list b '+ 1)) '/ (list b '+ 1)))
	 ((guard (list (list 'sec a) (list 'tan b) c)
		 (and (variable? a) (variable? b) (char= a b) (dx? c)))
	  (list 'sec a))
	 ((guard (list (list 'csc a) (list 'cot b) c)
		 (and (variable? a) (variable? b) (char= a b) (dx? c)))
	  (list '- 'csc a))
	 ((guard (list (list 'sin m a) (list 'cos n b) c)
		 (and (numberp m) (numberp n) (/= m n) (variable? a) (variable? b) (char= a b) (dx? c)))
	  (list '- (list (list 'cos (- m n) a) '/ (* 2 (- m n))) '-
		(list (list 'cos (+ m n) a) '/ (* 2 (+ m n)))))
	 ((guard (list (list 'sin m a) (list 'sin n b) c)
		 (and (numberp m) (numberp n) (/= m n) (variable? a) (variable? b) (char= a b) (dx? c)))
	  (list (list (list 'sin (- m n) a) '/ (* 2 (- m n))) '- 
		(list (list 'sin (+ m n) a) '/ (* 2 (+ m n)))))
	 ((guard (list (list 'cos m a) (list 'cos n b) c)
		 (and (numberp m) (numberp n) (/= m n) (variable? a) (variable? b) (char= a b) (dx? c)))
	  (list (list (list 'sin (- m n) a) '/ (* 2 (- m n))) '+
		(list (list 'sin (+ m n) a) '/ (* 2 (+ m n)))))))

(defun algTran (func)
  (cond
    ((and (constant? (car func)) (dx? (car (last func))))
     (list (car func) (integral (cdr func))))
    ((eq '- (car func))
     (list '- (integral (cdr func))))
    ((and (sigma? (car func)) (dx? (car (last func))))                    
     (mapcar #'integral (insertDx (combineNegs (car func)) (car (last func)))))
    (t nil)))
	  
	 
(defun integral (func)
  (cond ((elf func) (elf func))
	((algTran func) (algTran func))
	(t nil)))

(defun dx? (elem)
  (if (stringp elem)
    (and (= (length elem) 2)
	 (char= (char elem 0) #\d)
	 (alpha-char-p (char elem 1)))
    nil))

(defun constant? (elem)
  (cond ((numberp elem) elem)
	((characterp elem)
	 (if (upper-case-p elem)
	   elem
	   nil))
	 (t nil)))

(defun variable? (elem)
  (cond ((characterp elem)
	 (if (lower-case-p elem)
	   elem
	   nil))
	(t nil)))

(defun sigma? (elem)
  (if (listp elem)
  (cond ((eq '- (cadr elem)) t)
	((eq '+ (cadr elem)) t)
	((eq '- (caddr elem)) t)
	((eq '+ (caddr elem)) t)
	(t nil))
  nil))

(defun combineNegs (elem)
  (cond ((eq '- (car elem))
	 (cons (cons '- (list (cadr elem))) 
	       (combineNegs (cddr elem))))		
	((eq '+ (car elem))
	 (cons (list (cadr elem))
	       (combineNegs (cddr elem))))
	((null elem) '())
	(t (cons (list (car elem)) (combineNegs (cdr elem))))))

(defun insertDx (sigma dx)
  (mapcar #'(lambda (x) (append x (list dx))) sigma))

(defun insertPlus (func)
  (if (= (length func) 1)
    (list (car func))
    (append (list (car func)) (list '+) (insertPlus (cdr func)))))

(defun derive (func)
  (match func
	 ((guard (list (list a) b) (and (constant? a) (dx? b)))
	  0)
	 ((guard (list (list a) b) (and (variable? a) (dx? b) (char= a (char b 1))))
	  1)
	 ((guard (list a b c) (dx? c))
	  (list a (derive (append (list b) (list c))) '+ (derive (append (list a) (list c))) b))
	 ((guard (list (list 'exp a) b) (dx? b))
	  (list (derive (list (list a) b)) '* (list 'exp a)))
	 ((guard (list (list 'expt a b) c) 
	  (and (dx? c) (char= a (char c 1)) (numberp b) (/= 0 b)))
	  (list (derive (list (list a) c)) '* b (list 'expt a (- b 1))))
	 ))

; Get '( _ ("dx")) to '(_ "dx")
(defun simplify (expression)
  (if (listp expression)
    (cond ((and (eq '* (cadr expression))
		(or (eq 0 (car expression)) (eq 0 (caddr expression))))
	   0)
	  ((and (eq '* (cadr expression)) (eq 1 (car expression)))
	   (caddr expression))
	  ((and (eq '* (cadr expression)) (eq 1 (caddr expression)))
	   (car expression))
	  ((and (eq '+ (cadr expression)) (eq 0 (car expression)))
	   (caddr expression))
	  ((and (eq '+ (cadr expression)) (eq 0 (caddr expression)))
	   (car expression))
	  ((and (eq '- (cadr expression)) (eq 0 (caddr expression)))
	   (car expression))
	  ((and (eq 'expt (car expression)) (eq 0 (caddr expression)))
	   1)
	  ((and (eq 'expt (car expression)) (eq 1 (caddr expression)))
	   (cadr expression))
	  (t expression))
    expression))

(defun function? (expression)
  nil)
